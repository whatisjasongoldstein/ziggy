{"version":3,"file":"static/webpack/static/development/pages/index.js.2c6044062cdcb062b14c.hot-update.js","sources":["webpack:///./components/lazyloaded-image.js","webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/arrayWithHoles.js","webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/iterableToArrayLimit.js","webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/nonIterableRest.js","webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray.js"],"sourcesContent":["import { useRef, useEffect, useState, Component } from \"react\";\n\nlet observer;\nconst observerCallbackHandlers = {};\n\n// new IntersectionObserver(\n//   (entries, observerInstance) => {\n//     // checks to see if the element is intersecting\n//     if (entries[0].intersectionRatio > 0) {\n//       // if it is update the state, we set triggered\n//       // as to not re-observe the element\n//       setState({\n//         inView: true,\n//         triggered: true\n//       });\n//       // unobserve the element\n//       observerInstance.unobserve(ref.current);\n//     }\n//     return;\n//   },\n// {\n//   rootMargin: \"500px\"\n// }\n// );\n\nfunction getObserver() {\n  if (!process.browser || observer) {\n    return observer;\n  }\n\n  observer = new IntersectionObserver(\n    (entries, observerInstance) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          console.log(entry);\n          observerCallbackHandlers[entry.target]();\n        }\n      });\n    },\n    {\n      rootMargin: \"500px\"\n    }\n  );\n\n  return observer;\n}\n\n/**\n * Inspired by https://billyjacoby.dev/intersection-observer-react-hooks\n */\nexport const useIntersectionObserver = ref => {\n  // configure the state\n  const [state, setState] = useState({\n    inView: false,\n    triggered: false\n  });\n\n  // Use this to cache the observer across lifecycles\n  const observerInstance = getObserver();\n\n  // Obviously this only works in the browser\n  // if (process.browser && !observerRef.current) {\n  //   console.log(\"Observer created\");\n  //   observerRef.current = new IntersectionObserver(\n  //     (entries, observerInstance) => {\n  //       // checks to see if the element is intersecting\n  //       if (entries[0].intersectionRatio > 0) {\n  //         // if it is update the state, we set triggered\n  //         // as to not re-observe the element\n  //         setState({\n  //           inView: true,\n  //           triggered: true\n  //         });\n  //         // unobserve the element\n  //         observerInstance.unobserve(ref.current);\n  //       }\n  //       return;\n  //     },\n  //     {\n  //       rootMargin: \"500px\"\n  //     }\n  //   );\n  // }\n\n  useEffect(() => {\n    // check that the element exists, and has not\n    // already been triggered\n    if (observerInstance && ref.current && !state.triggered) {\n      observerCallbackHandlers[ref.current] = function() {\n        console.log(ref.current.outerHTML);\n      };\n      observerInstance.observe(ref.current);\n    }\n\n    return function() {\n      if (observerInstance) {\n        observerInstance.unobserve(ref.current);\n      }\n    };\n  });\n\n  return [state.inView];\n};\n\nexport default function LazyLoadedImage({ src, alt }) {\n  const elementRef = useRef(null);\n  const [inView] = useIntersectionObserver(elementRef);\n\n  return (\n    <img\n      ref={elementRef}\n      key={src}\n      className=\"lazyload\"\n      src={inView ? src : \"\"}\n      alt={alt}\n    />\n  );\n}\n\n// class LazyLoadedImage extends Component {\n//   constructor() {\n//     super();\n//     this.state = {\n//       inView: false\n//     };\n\n//     this.elementRef = React.createRef();\n//   }\n\n//   render() {\n//     let { inView } = this.state;\n//     const { src, alt } = this.props;\n//     // inView = true;\n\n//     return (\n//       <img\n//         ref={this.elementRef}\n//         key={src}\n//         className=\"lazyload\"\n//         src={inView ? src : \"\"}\n//         alt={alt}\n//       />\n//     );\n//   }\n// }\n\n// export default LazyLoadedImage;\n","import _Array$isArray from \"../../core-js/array/is-array\";\nexport default function _arrayWithHoles(arr) {\n  if (_Array$isArray(arr)) return arr;\n}","import _getIterator from \"../../core-js/get-iterator\";\nexport default function _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = _getIterator(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AAKA;AACA;AAEA;;;;;AAGA;AACA;AADA;AAGA;AACA;AAFA;AAFA;AAAA;AACA;AACA;AAMA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAFA;AAAA;AAAA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AClJA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;A","sourceRoot":""}