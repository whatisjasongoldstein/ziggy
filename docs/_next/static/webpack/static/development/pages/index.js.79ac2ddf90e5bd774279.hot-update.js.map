{"version":3,"file":"static/webpack/static/development/pages/index.js.79ac2ddf90e5bd774279.hot-update.js","sources":["webpack:///./components/lazyloaded-image.js"],"sourcesContent":["import dynamic from \"next/dynamic\";\nimport ReactDOM from \"react-dom\";\nimport { Component, useRef, useEffect, useState } from \"react\";\nimport { findDOMNode } from \"react-dom\";\n\n// export default class LazyLoadedImage extends Component {\n//   constructor() {\n//     super();\n//     this.elRef = React.createRef();\n//     this.state = {\n//       src: \"\"\n//     };\n//   }\n\n//   handleObserver(entries, observer) {\n//     console.log(\"!\");\n//     const isIntersecting = entries[0].isIntersecting;\n\n//     if (isIntersecting) {\n//       this.setState({ src: this.props.src });\n//     }\n//     this.unobserve();\n//   }\n\n//   componentDidMount() {\n//     this.observer = new IntersectionObserver(\n//       this.handleObserver.bind(this), //callback\n//       {\n//         root: null,\n//         rootMargin: \"500px\"\n//       }\n//     );\n//     console.log(this.observer);\n//     this.el = findDOMNode(this);\n//     console.log(this.el);\n//     this.observer.observe(this.el);\n//   }\n\n//   unobserve() {\n//     if (this.el && this.observer) {\n//       // Remove the observation listener\n//       this.observer.unobserve(this.el);\n//     }\n\n//     this.observer = null;\n//   }\n\n//   componentWillUnmount() {\n//     this.unobserve();\n//   }\n\n//   render() {\n//     const { src, alt } = this.props;\n//     const activeSrc = this.state.src;\n//     return <img key={src} className=\"lazyload\" src={activeSrc} alt={alt} />;\n//   }\n// }\n\nexport const useIntersectionObserver = (\n  ref,\n  { threshold, root, rootMargin }\n) => {\n  // configure the state\n  const [state, setState] = useState({\n    inView: false,\n    triggered: false,\n    entry: undefined\n  });\n\n  let observer;\n  if (process.browser) {\n    observer =\n      observer ||\n      new IntersectionObserver(\n        (entries, observerInstance) => {\n          // checks to see if the element is intersecting\n          if (entries[0].intersectionRatio > 0) {\n            // if it is update the state, we set triggered as to not re-observe the element\n            setState({\n              inView: true,\n              triggered: true,\n              entry: observerInstance\n            });\n            // unobserve the element\n            observerInstance.unobserve(ref.current);\n          }\n          return;\n        },\n        {\n          threshold: threshold || 0,\n          root: root || null,\n          rootMargin: rootMargin || \"0%\"\n        }\n      );\n  }\n\n  useEffect(() => {\n    // check that the element exists, and has not already been triggered\n    if (observer && ref.current && !state.triggered) {\n      observer.observe(ref.current);\n    }\n  });\n\n  return [state.inView, state.entry];\n};\n\nexport default function LazyLoadedImage({ src, alt }) {\n  const elementRef = useRef(null);\n  const [inView, entry] = useIntersectionObserver(elementRef, {\n    threshold: 0\n  });\n\n  useEffect(() => {}, [inView]);\n\n  return (\n    <img\n      ref={elementRef}\n      key={src}\n      className=\"lazyload\"\n      src={inView ? src : \"\"}\n      alt={alt}\n    />\n  );\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AACA;AAAA;AADA;AAGA;AACA;AACA;AAHA;AAFA;AAAA;AACA;AAOA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AAFA;AAGA;AADA;AAFA;AAAA;AAAA;AACA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;;;;A","sourceRoot":""}